“elasticsearch 里面桶的叫法和 SQL 里面分组的概念是类似的，一个桶就类似 SQL 里面的一个 group，多级嵌套的 aggregation， 类似 SQL
里面的多字段分组（group by field1,field2, …..），注意这里仅仅是概念类似，底层的实现原理是不一样的。
terms 桶基于我们的数据动态构建桶；它并不知道到底生成了多少桶。 大多数时候对单个字段的聚合查询还是非常快的， 但是当需要同时聚合多个字
段时，就可能会产生大量的分组，最终结果就是占用 es 大量内存，从而导致 OOM 的情况发生。

假设我们现在有一些关于电影的数据集，每条数据里面会有一个数组类型的字段存储表演该电影的所有演员的名字。
	{
	  "actors" : [
	    "Fred Jones",
	    "Mary Jane",
	    "Elizabeth Worthing"
	  ]
	}
如果我们想要查询出演影片最多的十个演员以及与他们合作最多的演员，使用聚合是非常简单的：
	{
	  "aggs" : {
	    "actors" : {
	      "terms" : {
	         "field" : "actors",
	         "size" :  10
	      },
	      "aggs" : {
	        "costars" : {
	          "terms" : {
	            "field" : "actors",
	            "size" :  5
	          }
	        }
	      }
	    }
	  }
	}

深度优先与广度优先（Depth-First Versus Breadth-First）编辑
Elasticsearch 允许我们改变聚合的 集合模式 ，就是为了应对这种状况。 我们之前展示的策略叫做 深度优先 ，它是默认设置， 先构建完整的树，然
后修剪无用节点。 深度优先 的方式对于大多数聚合都能正常工作，但对于如我们演员和联合演员这样例子的情形就不太适用。
为了应对这些特殊的应用场景，我们应该使用另一种集合策略叫做 广度优先 。这种策略的工作方式有些不同，它先执行第一层聚合， 再 继续下一层聚合
之前会先做修剪。
在我们的示例中， actors 聚合会首先执行，在这个时候，我们的树只有一层，但我们已经知道了前 10 位的演员！这就没有必要保留其他的演员信息，
因为它们无论如何都不会出现在前十位中。

要使用广度优先，只需简单 的通过参数 collect 开启：
	{
	  "aggs" : {
	    "actors" : {
	      "terms" : {
	         "field" :        "actors",
	         "size" :         10,
	         "collect_mode" : "breadth_first" 按聚合来开启 breadth_first 。
	      },
	      "aggs" : {
	        "costars" : {
	          "terms" : {
	            "field" : "actors",
	            "size" :  5
	          }
	        }
	      }
	    }
	  }
	}

广度优先仅仅适用于每个组的聚合数量远远小于当前总组数的情况下，因为广度优先会在内存中缓存裁剪后的仅仅需要缓存的每个组的所有数据，以便于
它的子聚合分组查询可以复用上级聚合的数据。
广度优先的内存使用情况与裁剪后的缓存分组数据量是成线性的。对于很多聚合来说，每个桶内的文档数量是相当大的。 想象一种按月分组的直方图，总
组数肯定是固定的，因为每年只有12个月，这个时候每个月下的数据量可能非常大。这使广度优先不是一个好的选择，这也是为什么深度优先作为默认策
略的原因。
针对上面演员的例子，如果数据量越大，那么默认的使用深度优先的聚合模式生成的总分组数就会非常多，但是预估二级的聚合字段分组后的数据量相比
总的分组数会小很多所以这种情况下使用广度优先的模式能大大节省内存，从而通过优化聚合模式来大大提高了在某些特定场景下聚合查询的成功率。