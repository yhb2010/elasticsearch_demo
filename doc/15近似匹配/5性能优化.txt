短语查询和邻近查询都比简单的 query 查询代价更高 。 一个 match 查询仅仅是看词条是否存在于倒排索引中，而一个 match_phrase 查询是必须
计算并比较多个可能重复词项的位置。
一个简单的 term 查询比一个短语查询大约快 10 倍，比邻近查询(有 slop 的短语 查询)大约快 20 倍。当然，这个代价指的是在搜索时而不是索引
时。

一个查询可能会匹配成千上万的结果，但我们的用户很可能只对结果的前几页感兴趣。一个简单的 match 查询已经通过排序把包含所有含有搜索词条
的文档放在结果列表的前面了。事实上，我们只想对这些 顶部文档 重新排序，来给同时匹配了短语查询的文档一个额外的相关度升级。search API
通过 重新评分 明确支持该功能。重新评分阶段支持一个代价更高的评分算法--比如 phrase 查询--只是为了从每个分片中获得前 K 个结果。 然后会
根据它们的最新评分 重新排序。
该请求如下所示：
	GET /my_index/my_type/_search
	{
	    "query": {
	        "match": {
	            "title": {
	                "query":                "quick brown fox",
	                "minimum_should_match": "30%"
	            }
	        }
	    },
	    "rescore": {
	        "window_size": 50,
	        "query": {
	            "rescore_query": {
	                "match_phrase": {
	                    "title": {
	                        "query": "quick brown fox",
	                        "slop":  50
	                    }
	                }
	            }
	        }
	    }
	}
match 查询决定哪些文档将包含在最终结果集中，并通过 TF/IDF 排序。
window_size 是每一分片进行重新评分的顶部文档数量。
目前唯一支持的重新打分算法就是另一个查询，但是以后会有计划增加更多的算法。