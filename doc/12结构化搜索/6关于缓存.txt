让我们看看下面例子中的查询，它查找满足以下任意一个条件的电子邮件：
	在收件箱中，且没有被读过的
	不在 收件箱中，但被标注重要的
	GET /inbox/emails/_search
	{
	  "query": {
	      "constant_score": {
	          "filter": {
	              "bool": {
	                 "should": [
	                    { "bool": {
	                          "must": [
	                             { "term": { "folder": "inbox" }},
	                             { "term": { "read": false }}
	                          ]
	                    }},
	                    { "bool": {
	                          "must_not": {
	                             "term": { "folder": "inbox" }
	                          },
	                          "must": {
	                             "term": { "important": true }
	                          }
	                    }}
	                 ]
	              }
	            }
	        }
	    }
	}
两个过滤器是相同的，所以会使用同一 bitset 。
尽管其中一个收件箱的条件是 must 语句，另一个是 must_not 语句，但他们两者是完全相同的。这意味着在第一个语句执行后， bitset 就会被计算然后缓存起来
供另一个使用。当再次执行这个查询时，收件箱的这个过滤器已经被缓存了，所以两个语句都会使用已缓存的 bitset 。

检查一个倒排是非常快的，然后绝大多数查询组件却很少使用它。例如 term 过滤字段 "user_id" ：如果有上百万的用户，每个具体的用户 ID 出现的概率都很小。
那么为这个过滤器缓存 bitsets 就不是很合算，因为缓存的结果很可能在重用之前就被剔除了。
这种缓存的扰动对性能有着严重的影响。更严重的是，它让开发者难以区分有良好表现的缓存以及无用缓存。
为了解决问题，Elasticsearch 会基于使用频次自动缓存查询。如果一个非评分查询在最近的256次查询中被使用过（次数取决于查询类型），那么这个查询就会作
为缓存的候选。但是，并不是所有的片段都能保证缓存 bitset 。只有那些文档数量超过 10,000（或超过总文档数量的 3% )才会缓存 bitset 。因为小的片段可以
很快的进行搜索和合并，这里缓存的意义不大。
一旦缓存了，非评分计算的bitset会一直驻留在缓存中直到它被剔除。剔除规则是基于LRU的：一旦缓存满了，最近最少使用的过滤器会被剔除。